<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Benefits cliff</title>
		<script src="https://d3js.org/d3.v5.min.js"></script>
		<script src="thresholds.js"></script>
		<style type="text/css">
			.line {
              fill: none;
              stroke: #EF5285;
              stroke-width: 2px;
            }

			body {
			  font-family: Helvetica, Sans-serif;
			}

			.grid line {
			  stroke: lightgrey;
			  stroke-opacity: 0.5;
			  shape-rendering: crispEdges;
			}

			.grid path {
			  stroke-width: 0;
			}

		</style>
	</head>
	<body>
	  <div id = "familyDropdown" class="dropdown">Select Household Size:  </div>
		<script type="text/javascript">

		// python3 -m http.server 8888 &.


		//create margins
		var margin = {top: 90, right: 220, bottom: 60, left: 70};

		var width = 960 - margin.left - margin.right
  			height = 520 - margin.top - margin.bottom;

			// import dataset "https://ff-plots.s3.amazonaws.com/data/cliff_cdf.csv"
			d3.csv("https://ff-plots.s3.amazonaws.com/data/cliff_cdf.csv", function(d) {
              return {
                size: d.size,
                income: +d.income,
                cum_sum: +d.cum_sum,
                grouping: d.grouping
              };
            }).then(function(data) {

			// gridlines in x axis function
			function make_x_gridlines() {
			    return d3.axisBottom(xScale)
			}

			// gridlines in y axis function
			function make_y_gridlines() {
			    return d3.axisLeft(yScale)
			}

      // scales
			var xScale = d3.scaleLinear()
							.domain([0, d3.max(data, function(d) { return d.income; })])
							.range([0, width]);

			var yScale = d3.scaleLinear()
							.domain([0, d3.max(data, function(d) { return d.cum_sum; })])
							.range([height, 0]);

			var dollarFormat = d3.format("$")

			// axes
			var xAxis = d3.axisBottom(xScale)
										.tickFormat(dollarFormat)
			var yAxis = d3.axisLeft(yScale);

			// set the colour scale for lines
			var color = d3.scaleOrdinal(d3.schemeSet2);

			var bisectIncome = d3.bisector(function(d) { return d.income; }).left;

			// Create line element
			var simpleLine = d3.line()
			    .x(function(d) { return xScale(d.income); })
			    .y(function(d) { return yScale(d.cum_sum); });

			// Create SVG element
			var svg = d3.select("body").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom)
			  .append("g")
			    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		  // add the Y gridlines
		  svg.append("g")
		      .attr("class", "grid")
		      .call(make_y_gridlines()
		          .tickSize(-width)
		          .tickFormat("")
		      )

			// Nest the data by composition (family type)
      var nest = d3.nest()
  	  .key(function(d){
  	    return d.size;
  	  })
      .key(function(d){
        return d.grouping;
      })
  	  .entries(data);

			// variable for vertical lines
			var focus = svg.append("g")
                .style("display", "none");

			// create drop down menu
			var familyMenu = d3.select("#familyDropdown");

			// population drop-down menu
      familyMenu
	  		.append("select")
	  		.selectAll("option")
	          .data(nest)
	          .enter()
	          .append("option")
	          .attr("value", function(d){
	              return d.key;
	          })
	          .text(function(d){
	              return d.key;
	          });

         	// Function to create the initial graph
         	var initialGraph = function(family){

         		// Filter the data to include only family composition of interest
         		var selectFamily = nest.filter(function(d){
                        return d.key == family;
                      })

        	    var selectFamilyGroups = svg.selectAll(".familyGroups")
        		    .data(selectFamily, function(d){
        		      return d ? d.key : this.key;
        		    })
        		    .enter()
        		    .append("g")
        		    .attr("class", "familyGroups")

        		var initialPath = selectFamilyGroups.selectAll(".line")
        			.data(function(d) { return d.values; })
        			.enter()
        			.append("path")

        		initialPath
        			.attr("d", function(d){ return simpleLine(d.values) })
        			.attr("class", "line")
        			.style("stroke", function(d) { return color(d.key); })

						// create federal poverty guideline vertical lines ----------------

						// pull out poverty levels for family size, based on family composition selected
						// from drop down
						for(var i = 0; i < fpl.length; ++i) {
							if(fpl[i].size == family) {
								 var single_fpl = fpl[i]
								 { break; }
							 }
						 }

						 for(var i = 0; i < poverty_levels.length; ++i) {

							 	// thresholds are monthly thresholds, so multiply by 12 for yearly
								var fpl_threshold = single_fpl.levels[poverty_levels[i]] * 12

								svg.append('line')
									.attr("x1", xScale(fpl_threshold))
									.attr("x2", xScale(fpl_threshold))
									.attr("y1", height - 370)
									.attr("y2", height)
									.style("stroke", "gray")
									.style("stroke-width", 1)
									.style("stroke-dasharray", "2,2")
									.attr("class", poverty_levels[i])

								svg.append('text')
									.attr("x", xScale(fpl_threshold + 30))
									.attr("y", height - 366)
									.attr('transform', 'rotate(90 ' + xScale(fpl_threshold + 30) + ' ' + (height - 366) + ')')
									.attr("font-size", "12px")
									.text(poverty_text[i])
									.attr("class", poverty_levels[i]+"_text")
									.style("fill", "gray")

								}
								// end lines for federal poverty levels

								// subtitle showing family type

								// text for subtitle that is 'person' for 1 person, 'people' for 2 or more
								var person_people = ""
								person_people =  (family === '1') ? " person" : " people"

								svg.append("text")
								        .attr("x", (width / 2))
								        .attr("y", 0 - (margin.top / 2.3))
								        .attr("text-anchor", "middle")
								        .style("font-size", "14px")
								        .text("Household size: " + family + person_people)
												.attr('class', 'subtitle');
         	}

			// Create initial graph
      initialGraph("1")

      // Update the data
     	var updateGraph = function(family){

     		// Filter the data to include only family of interest
     		var selectFamily = nest.filter(function(d){
                    return d.key == family;
                  })

     		// Select all of the grouped elements and update the data
  	    var selectFamilyGroups = svg.selectAll(".familyGroups")
  		    .data(selectFamily)

  		    // Select all the lines and transition to new positions
          selectFamilyGroups.selectAll("path.line")
             .data(function(d){
                return (d.values);
              })
              .transition()
                .duration(500)
                .attr("d", function(d){
                  return simpleLine(d.values)
                });

				// add lines for poverty poverty_levels
				for(var i = 0; i < fpl.length; ++i) {
					if(fpl[i].size == family) {
						 var single_fpl = fpl[i]
						 { break; }
					 }
				 }

				 for(var i = 0; i < poverty_levels.length; ++i) {

						var fpl_threshold = single_fpl.levels[poverty_levels[i]] * 12

						svg.selectAll("."+poverty_levels[i])
						.transition()
							.duration(1000)
							.attr("x1", xScale(fpl_threshold))
							.attr("x2", xScale(fpl_threshold))

						svg.selectAll("."+poverty_levels[i]+"_text")
						.transition()
							.duration(1000)
							.attr("x", xScale(fpl_threshold  + 30))
							.attr('transform', 'rotate(90 ' + xScale(fpl_threshold + 30) + ' ' + (height - 366) + ')')

				}

				// end lines for poverty levels

				// update household size subtiutle
				person_people =  (family === '1') ? " person" : " people"

				svg.selectAll('.subtitle')
				.transition()
					.text("Household size: " + family + person_people)

			}

     	// Run update function when dropdown selection changes
     	familyMenu.on('change', function(){

     		// Find which family was selected from the dropdown
     		var selectedFamily = d3.select(this)
                .select("select")
                .property("value")

            // Run update function with the selected family composition
            updateGraph(selectedFamily)
        });

				// mouseover line --------------------------

        var mouseG = svg.append("g")
          .attr("class", "mouse-over-effects");

        mouseG.append("path") // this is the black vertical line to follow mouse
          .attr("class", "mouse-line")
          .style("stroke", "black")
          .style("stroke-width", "1px")
          .style("opacity", "0");

        var lines = document.getElementsByClassName('line');

        var mousePerLine = mouseG.selectAll('.mouse-per-line')
          .data(nest)
          .enter()
          .append("g")
          .attr("class", "mouse-per-line");

        mousePerLine.append("circle")
          .attr("r", 7)
        	.style("stroke", "grey")
          .style("fill", "none")
          .style("stroke-width", "1px")
          .style("opacity", "0");

        mousePerLine.append("text")
          .attr("transform", "translate(10,3)");

        mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
          .attr('width', width) // can't catch mouse events on a g element
          .attr('height', height)
          .attr('fill', 'none')
          .attr('pointer-events', 'all')
          .on('mouseout', function() { // on mouse out hide line, circles and text
            d3.select(".mouse-line")
              .style("opacity", "0");
            d3.selectAll(".mouse-per-line circle")
              .style("opacity", "0");
            d3.selectAll(".mouse-per-line text")
              .style("opacity", "0");
          })
          .on('mouseover', function() { // on mouse in show line, circles and text
            d3.select(".mouse-line")
              .style("opacity", "1");
            d3.selectAll(".mouse-per-line circle")
              .style("opacity", "1");
            d3.selectAll(".mouse-per-line text")
              .style("opacity", "1");
          })
          .on('mousemove', function() { // mouse moving over canvas
            var mouse = d3.mouse(this);
            d3.select(".mouse-line")
              .attr("d", function() {
                var d = "M" + mouse[0] + "," + height;
                d += " " + mouse[0] + "," + 0;
                return d;
              });

            d3.selectAll(".mouse-per-line")
              .attr("transform", function(d, i) {
                console.log(width/mouse[0])
                var xIncome = xScale.invert(mouse[0]),
                    bisect = d3.bisector(function(d) { return d.income; }).right;
                    idx = bisect(d.values, xIncome);

                var beginning = 0,
                    end = lines[i].getTotalLength(),
                    target = null;

                while (true){
                  target =  Math.floor((beginning + end) / 2);
                  pos = lines[i].getPointAtLength(target);
                  if ((target === end || target === beginning) && pos.x !== mouse[0]) {
                      break;
                  }
                  if (pos.x > mouse[0])      end = target;
                  else if (pos.x < mouse[0]) beginning = target;
                  else break; //position found
                }

                d3.select(this).select('text')
                  .text(Math.round(yScale.invert(pos.y)))
									.style("font-size", "12px");

                return "translate(" + mouse[0] + "," + pos.y +")";
              });
          });
			// end mouseover line --------------------------

			// chart title
			svg.append("text")
			        .attr("x", (width / 2))
			        .attr("y", 0 - (margin.top / 1.5))
			        .attr("text-anchor", "middle")
			        .style("font-size", "16px")
			        .text("Forsyth County, NC Household Incomes");

			// draw y axis with labels and move in from the size by the amount of padding
      svg.append("g")
      	.attr("class", "axis")
          .attr("transform", "translate(" + 0 + ",0)")
          .call(yAxis);

      // draw x axis with labels and move to the bottom of the chart area
      svg.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + (height) + ")")
          .call(xAxis);

			// text label for the x axis
		  svg.append("text")
					.attr("x", width/2)
					.attr("y", (height + margin.bottom) - 15)
		      .style("text-anchor", "middle")
		      .text("Total yearly household income");

			// text label for the y axis
		  svg.append("text")
		      .attr("transform", "rotate(-90)")
		      .attr("y", 0 - margin.left)
		      .attr("x",0 - (height / 2))
		      .attr("dy", "1em")
		      .style("text-anchor", "middle")
		      .text("Number of people in households below income level");

			// add text explaning the abbreviations FPG, AMI, SMI
			// use for loop
			var abbreviations = ["FPG = Federal Poverty Guideines",
													 "SMI = State Median Income"]

			var abb_y = [26, 14, 2]

			for(var i = 0; i < abbreviations.length; ++i) {

				svg.append("text")
					.attr("x", 10 - margin.left)
					.attr("y", (height + margin.bottom) - abb_y[i])
					.text(abbreviations[i])
					.attr("fill", "gray")
					.attr("font-size", "12px")

				}

    });

		</script>
	</body>
</html>
