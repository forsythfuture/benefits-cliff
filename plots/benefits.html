<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Benefits cliff</title>
		<script src="https://d3js.org/d3.v5.min.js"></script>
		<style type="text/css">
			.line {
              fill: none;
              stroke: #EF5285;
              stroke-width: 2px;
            }

			body {
			  font-family: Helvetica, Sans-serif;
			}

			.grid line {
			  stroke: lightgrey;
			  stroke-opacity: 0.5;
			  shape-rendering: crispEdges;
			}

			.grid path {
			  stroke-width: 0;
			}

		</style>
	</head>
	<body>
	  <div id = "familyDropdown" class="dropdown">Select Family Size:  </div>
		<script type="text/javascript">

		// python3 -m http.server 8888 &.


		//create margins
		var margin = {top: 20, right: 220, bottom: 60, left: 70};

		var width = 960 - margin.left - margin.right,
  			height = 500 - margin.top - margin.bottom;

				// JSON dataset of federal poverty federal_poverty_guidelines
	 		 // will be used to draw vertical lines at 100%, 130%, 185%, and 200% of fpg

 		 const fpl = [{
 			 "name": "1 adult",
 			 "levels": {
 				 "a": 1012,
 				 "b": Math.round(1012 * 1.3),
 				 "c": Math.round(1012 * 1.85),
 				 "d": Math.round(1012 * 2)
 			 }
 		 }, {
 			 "name": "1 adult, 1 child",
 			 "levels": {
 				 "a": 1372,
 				 "b": Math.round(1372 * 1.3),
 				 "c": Math.round(1372 * 1.85),
 				 "d": Math.round(1372 * 2)
 			 }
 		 }, {
 			 "name": "1 adult, 2 children",
 			 "levels": {
 				 "a": 1732,
 				 "b": Math.round(1732 * 1.3),
 				 "c": Math.round(1732 * 1.85),
 				 "d": Math.round(1732 * 2)
 			 }
 		 }, {
 			 "name": "1 adult, 3 children",
 			 "levels": {
 				 "a": 2092,
 				 "b": Math.round(2092 * 1.3),
 				 "c": Math.round(2092 * 1.85),
 				 "d": Math.round(2092 * 2)
 			 }
 		 }];


			// import dataset
			d3.csv("benefits.csv", function(d) {
              return {
                composition: d.composition,
                monthly_income: +d.monthly_income,
                payment: +d.payment,
                benefit: d.benefit,
              };
            }).then(function(data) {

			// gridlines in x axis function
			function make_x_gridlines() {
			    return d3.axisBottom(xScale)
			        //.ticks(10)
			}

			// gridlines in y axis function
			function make_y_gridlines() {
			    return d3.axisLeft(yScale)
			        //.ticks(10)
			}

      // scales
			var xScale = d3.scaleLinear()
							.domain([0, d3.max(data, function(d) { return d.monthly_income; })])
							.range([0, width]);

			var yScale = d3.scaleLinear()
							.domain([0, d3.max(data, function(d) { return d.payment; })])
							.range([height, 0]);

			var dollarFormat = d3.format("$")

			// axes
			var xAxis = d3.axisBottom(xScale)
										.tickFormat(dollarFormat)
			var yAxis = d3.axisLeft(yScale)
										.tickFormat(dollarFormat);

			// set the colour scale for lines
			var color = d3.scaleOrdinal(d3.schemeSet2);

			var bisectIncome = d3.bisector(function(d) { return d.monthly_income; }).left;

			// Create line element
			var simpleLine = d3.line()
			    .x(function(d) { return xScale(d.monthly_income); })
			    .y(function(d) { return yScale(d.payment); });

			// Create SVG element
			var svg = d3.select("body").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom)
			  .append("g")
			    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			// add legend
			var legend = svg.selectAll('g')
	        .data(d3.map(data, function(d){return d.benefit;}).keys())
	        .enter()
	      .append('g')
	        .attr('class', 'legend');

			var yLegendOffest = 30

	    legend.append('circle')
	        .attr('cx', width + 15)
	        .attr('cy', function(d, i){ return (i *  20) + yLegendOffest;})
					.attr('r', 7)
	        //.attr('width', 10)
	        //.attr('height', 10)
	        .style('fill', function(d) {
	          return color(d);
	        });

			legend.append('text')
				.attr('x', width + 28)
				.attr('y', function(d, i){ return ((i *  20) + 5) + yLegendOffest;})
				.text(function(d){ return d; });

			// end legend

			// add the X gridlines
		  // svg.append("g")
		  //     .attr("class", "grid")
		  //     .attr("transform", "translate(0," + height + ")")
		  //     .call(make_x_gridlines()
		  //         .tickSize(-height)
		  //         .tickFormat("")
		  //     )

		  // add the Y gridlines
		  svg.append("g")
		      .attr("class", "grid")
		      .call(make_y_gridlines()
		          .tickSize(-width)
		          .tickFormat("")
		      )

			// Nest the data by composition (family type) and benefit type
      var nest = d3.nest()
  	  .key(function(d){
  	    return d.composition;
  	  })
  	  .key(function(d){
  	  	return d.benefit;
  	  })
  	  .entries(data);

			// variable for vertical lines
			var focus = svg.append("g")
                .style("display", "none");

			// create drop down menu
			var familyMenu = d3.select("#familyDropdown");

			// population drop-down menu
      familyMenu
	  		.append("select")
	  		.selectAll("option")
	          .data(nest)
	          .enter()
	          .append("option")
	          .attr("value", function(d){
	              return d.key;
	          })
	          .text(function(d){
	              return d.key;
	          });

         	// Function to create the initial graph
         	var initialGraph = function(family){

         		// Filter the data to include only family composition of interest
         		var selectFamily = nest.filter(function(d){
                        return d.key == family;
                      })

        	    var selectFamilyGroups = svg.selectAll(".familyGroups")
        		    .data(selectFamily, function(d){
        		      return d ? d.key : this.key;
        		    })
        		    .enter()
        		    .append("g")
        		    .attr("class", "familyGroups")

        		var initialPath = selectFamilyGroups.selectAll(".line")
        			.data(function(d) { return d.values; })
        			.enter()
        			.append("path")

        		initialPath
        			.attr("d", function(d){ return simpleLine(d.values) })
        			.attr("class", "line")
        			.style("stroke", function(d) { return color(d.key); })

						// create federal poverty guideline vertical lines ----------------

						// pull out poverty levels for family size, based on family composition selected
						// from drop down
						for(var i = 0; i < fpl.length; ++i) {
							if(fpl[i].name == family) {
								 var single_fpl = fpl[i]
								 { break; }
							 }
						 }

						 var poverty_levels = ['a', 'b', 'c', 'd']
						 var poverty_text = ["100%", "130%", "185%", "200%"]

						 for(var i = 0; i < poverty_levels.length; ++i) {

								var fpl_threshold = single_fpl.levels[poverty_levels[i]]

								svg.append('line')//.selectAll(".fgp_lines")
									.attr("x1", xScale(fpl_threshold))
									.attr("x2", xScale(fpl_threshold))
									.attr("y1", height - 420)
									.attr("y2", height)
									.style("stroke", "gray")
									.style("stroke-width", 2)
									.style("stroke-dasharray", "2,2")
									.attr("class", poverty_levels[i])

								svg.append('text')
									.attr("x", xScale(fpl_threshold + 30))
									.attr("y", height - 416)
									.attr('transform', 'rotate(90 ' + xScale(fpl_threshold + 30) + ' ' + (height - 416) + ')')
									.attr("font-size", "12px")
									.text(poverty_text[i] + "  FPG")
									.attr("class", poverty_levels[i]+"_text")

								}
								// end lines for federal poverty levels
         	}

			// Create initial graph
      initialGraph("1 adult")

      // Update the data
     	var updateGraph = function(family){

     		// Filter the data to include only family of interest
     		var selectFamily = nest.filter(function(d){
                    return d.key == family;
                  })

     		// Select all of the grouped elements and update the data
  	    var selectFamilyGroups = svg.selectAll(".familyGroups")
  		    .data(selectFamily)

  		    // Select all the lines and transition to new positions
          selectFamilyGroups.selectAll("path.line")
             .data(function(d){
                return (d.values);
              })
              .transition()
                .duration(1000)
                .attr("d", function(d){
                  return simpleLine(d.values)
                });

				// add lines for poverty poverty_levels
				for(var i = 0; i < fpl.length; ++i) {
					if(fpl[i].name == family) {
						 var single_fpl = fpl[i]
						 { break; }
					 }
				 }

				 var poverty_levels = ['a', 'b', 'c', 'd']
				 var poverty_text = ["100%", "130%", "185%", "200%"]

				 for(var i = 0; i < poverty_levels.length; ++i) {

						var fpl_threshold = single_fpl.levels[poverty_levels[i]]

						svg.selectAll("."+poverty_levels[i])
						.transition()
							.duration(1000)
							.attr("x1", xScale(fpl_threshold))
							.attr("x2", xScale(fpl_threshold))

						svg.selectAll("."+poverty_levels[i]+"_text")
						.transition()
							.duration(1000)
							.attr("x", xScale(fpl_threshold  + 30))
							.attr('transform', 'rotate(90 ' + xScale(fpl_threshold + 30) + ' ' + (height - 416) + ')')
				}

				// end lines for poverty levels

			}

     	// Run update function when dropdown selection changes
     	familyMenu.on('change', function(){

     		// Find which family was selected from the dropdown
     		var selectedFamily = d3.select(this)
                .select("select")
                .property("value")

            // Run update function with the selected family composition
            updateGraph(selectedFamily)
        });

				// mouseover line --------------------------

        var mouseG = svg.append("g")
          .attr("class", "mouse-over-effects");

        mouseG.append("path") // this is the black vertical line to follow mouse
          .attr("class", "mouse-line")
          .style("stroke", "black")
          .style("stroke-width", "1px")
          .style("opacity", "0");

        var lines = document.getElementsByClassName('line');

        var mousePerLine = mouseG.selectAll('.mouse-per-line')
          .data(nest)
          .enter()
          .append("g")
          .attr("class", "mouse-per-line");

        mousePerLine.append("circle")
          .attr("r", 7)
        	.style("stroke", "grey")
          .style("fill", "none")
          .style("stroke-width", "1px")
          .style("opacity", "0");

        mousePerLine.append("text")
          .attr("transform", "translate(10,3)");

        mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
          .attr('width', width) // can't catch mouse events on a g element
          .attr('height', height)
          .attr('fill', 'none')
          .attr('pointer-events', 'all')
          .on('mouseout', function() { // on mouse out hide line, circles and text
            d3.select(".mouse-line")
              .style("opacity", "0");
            d3.selectAll(".mouse-per-line circle")
              .style("opacity", "0");
            d3.selectAll(".mouse-per-line text")
              .style("opacity", "0");
          })
          .on('mouseover', function() { // on mouse in show line, circles and text
            d3.select(".mouse-line")
              .style("opacity", "1");
            d3.selectAll(".mouse-per-line circle")
              .style("opacity", "1");
            d3.selectAll(".mouse-per-line text")
              .style("opacity", "1");
          })
          .on('mousemove', function() { // mouse moving over canvas
            var mouse = d3.mouse(this);
            d3.select(".mouse-line")
              .attr("d", function() {
                var d = "M" + mouse[0] + "," + height;
                d += " " + mouse[0] + "," + 0;
                return d;
              });

            d3.selectAll(".mouse-per-line")
              .attr("transform", function(d, i) {
                console.log(width/mouse[0])
                var xIncome = xScale.invert(mouse[0]),
                    bisect = d3.bisector(function(d) { return d.monthly_income; }).right;
                    idx = bisect(d.values, xIncome);

                var beginning = 0,
                    end = lines[i].getTotalLength(),
                    target = null;

                while (true){
                  target =  Math.floor((beginning + end) / 2);
                  pos = lines[i].getPointAtLength(target);
                  if ((target === end || target === beginning) && pos.x !== mouse[0]) {
                      break;
                  }
                  if (pos.x > mouse[0])      end = target;
                  else if (pos.x < mouse[0]) beginning = target;
                  else break; //position found
                }

                d3.select(this).select('text')
                  .text("$" + yScale.invert(pos.y).toFixed(2))
									.style("font-size", "12px");

                return "translate(" + mouse[0] + "," + pos.y +")";
              });
          });
			// end mouseover line --------------------------

			// draw y axis with labels and move in from the size by the amount of padding
      svg.append("g")
      	.attr("class", "axis")
          .attr("transform", "translate(" + 0 + ",0)")
          .call(yAxis);

      // draw x axis with labels and move to the bottom of the chart area
      svg.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + (height) + ")")
          .call(xAxis);

			// text label for the x axis
		  svg.append("text")
		      .attr("transform",
		            "translate(" + (width/2) + " ," +
		                           (height + margin.top + 30) + ")")
		      .style("text-anchor", "middle")
		      .text("Monthly Wages");

			// text label for the y axis
		  svg.append("text")
		      .attr("transform", "rotate(-90)")
		      .attr("y", 0 - margin.left)
		      .attr("x",0 - (height / 2))
		      .attr("dy", "1em")
		      .style("text-anchor", "middle")
		      .text("Benefit Amount");

    });

		</script>
	</body>
</html>
